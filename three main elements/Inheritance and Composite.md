# 상속(Inheritance) 과 합성(Composite)

상속을 배울 때 알아둬야 할 가장 중요한 숙어는 `is a kind of(~의 한 종류)` 이다.

> 뽀로로 is a kind of 펭귄 : 뽀로로는 펭귄의 한 종류이다.

즉, 상속을 하기 위해서는 위 관계가 형성되어야 한다.

```java
@Getter @Setter
public class Penguin {
  protected String gender;
  protected String age;
  protected String name;
}
```

```java
@Getter @Setter
public class Pororo extends Penguin {
  private String favoriteFood;
}
```

```java
public class App {
  public static void main(String[] args) {
    Pororo pororo = new Pororo();
    pororo.setName("뽀로로");
    pororo.setAge("5");
    pororo.setGender("Male");
    pororo.setFavoriteFood("Fish");
  }
}
```

Pororo 클래스는 Penguin 클래스를 상속받고 있습니다. 상속의 가장 큰 장점은 상속받은 `속성과 메서드`들을 `재사용`할 수 있다. Penguin 클래스에서 속성 접근 지시자를 protected 로 한 
이유는 상속받은 경우에만 한해서 속성을 재사용할 수 있도록 하기 위함이다.

상속과 비슷한 기법이 있는데 바로 `합성(Composite)` 이라는 것이다. 상속과 합성은 모두 재사용성을 높이기 위한 기법이다.

- 상속의 장점
  - 클래스 상속은 `컴파일 시점에 정적`으로 정의되고 프로그래밍 언어가 직접 지원하므로 그대로 사용하면 된다.
  - 클래스 상속으로 부모 클래스의 구현을 쉽게 수정할 수도 잇는데, 서브클래스는 모든 연산이 아닌 일부만 재정의할 수도 있다.
- 상속의 단점
  - `런타임에 상속받은 부모 클래스의 구현을 변경할 수 없다.`
  - 부모 클래스는 서브클래스의 물리적 표현의 최소 부분만을 정의하기 때문에 서브클래스는 부모 클래스가 정의한 물리적 표현들을 전부 또는 일부 상속 받는다.
  - 부모 클래스가 변경되면 서브클래스도 변경된다.
  - 상속은 부모 클래스의 구현이 서브클래스에 다 드러나는 것이기 때문에 상속은 캡슐화를 파괴한다고 주장하는 의견도 있다.
  - 이러한 종속성은 유연성과 재사용성을 떨어뜨린다.
    - 해결방법 : 추상 클래스에서만 상속을 받으면 된다. 이미 추상 클래스를 상속했다는 것은 구현이 아닌 인터페이스를 상속한 것이므로 구현 자체는 서브클래스가 정의하고, 구현이 변경되면 서브클래스만 변경하면 된다.
    
- 합성의 장점
  - 클래스 상속보다 객체 합성을 선호하는 이유는 각 클래스의 캡슐화를 유지할 수 있고, 각 클래스의 한 가지 작업에 집중할 수 있기 때문이다.
  - 객체 합성으로 설계되면 클래스의 수는 적어지고 객체의 수는 좀더 많아질 수 있지만, 시스템의 행동을 런타임에 결정할 수 있게 된다.
  - 객체 합성이 클래스 합성보다 더 나은 방법이다.
  
이렇듯 상속보다는 합성이 일반적으로 더 나은 방법이다.

합성을 상속만큼 더 강력하게 사용하기 위한 기법이 있는데 바로 `위임(delegation)`이다.

```java
public class A {
  private B b;
}
```

위임은 A 와 B 클래스가 있다고 할 때, A 클래스를 B 클래스의 서브클래스로 만드는 대신 A 클래스는 B 클래스를 자신의 인스턴스 변수로 만들고, B 클래스에 정의된 행동이 필요할 때는 B 클래스에 위임함으로써 B 클래스의 행동을 재사용할 수 있다.

위임의 가장 중요한 장점은 `런타임에 행동의 복합을 가능`하게 하고, 복합하는 방식도 변경해 준다. 위임이 갖는 단점은, 객체 합성을 통해 소프트웨어 설계의 유연성을 보장하는 방법과 동일하게 동적인데다가 고도로 매개변수화된 소프트웨어는 정적인 소프트웨어 구조보다 이해하기 어렵다는 것이다. 그 이유는 클래스에 상호작용이 다 정의되어 있는 것이 아니라 런타임 객체에 따라서 그 결과가 다르기 때문이다. 또한 런타임에 비효율적일 수 있다.

즉, 상속과 합성 and 위임의 가장 큰 차이 중 하나는 상속은 정적바인딩(컴파일시에 행동이 결정된다.)이며, 합성과 위임은 동적바인딩(런타임시에 행동을 결정할 수 있다.)이라는 개념을 사용한다.

정적바인딩과 동적바인딩에 대해서는 다형성 부분에서 더 자세하게 다루겠다.

## white-box reuse and black-box reuse

클래스 상속을 `서브클래싱` 이라고 하며, 서브클래싱에 의한 재사용을 `화이트박스 재사용(white-box reuse)` 이라고 한다. 화이트박스는 내부를 볼 수 있다는 의미에서 나온 말이다. 상속을 받으면 부모 클래스의 내부가 서브클래스에 공개되기 때문에 화이트박스인 셈이다.

객체 합성은 클래스 상속에 대한 대안이다. 다른 객체를 여러 개 붙여서 새로운 기능 혹은 객체를 구성하는 것을 의미한다. 객체를 합성하려면, 합성에 들어가는 객체들의 인터페이스를 명확하게 정의해 두어야 한다. 이런 스타일의 재사용을 `블랙박스 재사용(black-box reuse)` 이라고 한다. 객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용 되기 때문이다.
